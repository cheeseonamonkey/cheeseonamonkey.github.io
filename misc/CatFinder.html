<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Pet Finder</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="flex flex-col h-screen bg-stone-100">
    <div class="flex-grow flex justify-center items-center p-4">
        <video id="webcam" autoplay playsinline
            class="w-full h-auto max-h-96 md:max-h-[80vh] lg:max-h-[85vh] rounded-lg border border-gray-300 shadow-md"></video>
        <canvas id="canvas" class="hidden"></canvas>
    </div>

    <h3 class="underline bold">Identified pets (cats and dogs):</h3>
    <div id="pet-images"
        class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4 p-4 bg-white border border-gray-300 shadow-md rounded-lg">
    </div>

    <div id="error-log" class="p-4 bg-red-100 text-red-700 border border-red-300 rounded-lg mt-4"></div>

    <script>
        function logError(error) {
            const errorLog = document.getElementById("error-log");
            const errorMsg = document.createElement("div");
            errorMsg.innerText = `Error: ${error}`;
            errorLog.appendChild(errorMsg);
        }

        window.onerror = function (message, source, lineno, colno, error) {
            logError(`${message} at ${source}:${lineno}:${colno}`);
        };

        async function setupWebcam() {
            const webcam = document.getElementById("webcam");
            try {
                const isMobile = /Mobi|Android/i.test(navigator.userAgent);
                const constraints = { video: isMobile ? { facingMode: { exact: "environment" } } : { video: true } };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                webcam.srcObject = stream;
                return true;
            } catch (error) {
                if (error.name === 'OverconstrainedError') {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                        webcam.srcObject = stream;
                        return true;
                    } catch (fallbackError) {
                        logError(`Error with default webcam setup: ${fallbackError}`);
                    }
                } else {
                    logError(`Error accessing webcam: ${error}`);
                }
                return false;
            }
        }

        async function detectObjects() {
            const webcam = document.getElementById("webcam");
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");
            const petImagesContainer = document.getElementById("pet-images");
            let model;

            try {
                model = await cocoSsd.load();
            } catch (error) {
                logError(`Error loading COCO-SSD model: ${error}`);
                return;
            }

            const detectionInterval = 350; // Detection interval in ms
            let lastDetectionTime = 0;

            let previousPetCount = 0; // To track the previous count of detected pets

            async function detectFrame() {
                const now = Date.now();
                if (now - lastDetectionTime < detectionInterval) {
                    requestAnimationFrame(detectFrame);
                    return;
                }

                lastDetectionTime = now;

                canvas.width = webcam.videoWidth;
                canvas.height = webcam.videoHeight;
                ctx.drawImage(webcam, 0, 0);

                try {
                    const predictions = await model.detect(canvas);
                    const pets = predictions.filter((pred) => pred.class === "cat" || pred.class === "dog");

                    const currentPetCount = pets.length;

                    if (currentPetCount < previousPetCount) {
                        // If the count decreases, pause for 1 second
                        setTimeout(() => {
                            previousPetCount = currentPetCount;
                            detectFrame(); // Resume detection after 1 second
                        }, 1000);
                        return; // Exit early to avoid recursive calls during the sleep
                    }

                    // Clear the container and re-draw the detected pets
                    petImagesContainer.innerHTML = "";

                    pets.forEach((pet) => {
                        const { bbox } = pet;
                        const [x, y, width, height] = bbox;

                        const petCanvas = document.createElement("canvas");
                        const petCtx = petCanvas.getContext("2d");

                        const squareSize = Math.max(width, height);
                        petCanvas.width = squareSize;
                        petCanvas.height = squareSize;

                        const offsetX = (squareSize - width) / 2;
                        const offsetY = (squareSize - height) / 2;

                        petCtx.drawImage(canvas, x, y, width, height, offsetX, offsetY, width, height);

                        petCanvas.className = "border border-gray-300 rounded-lg shadow-md w-full";
                        petImagesContainer.appendChild(petCanvas);
                    });

                    previousPetCount = currentPetCount; // Update the previous count

                    requestAnimationFrame(detectFrame);
                } catch (error) {
                    logError(`Error during detection: ${error}`);
                }
            }

            detectFrame();
        }

        setupWebcam().then((isSuccess) => {
            if (isSuccess) {
                detectObjects();
            } else {
                logError("Webcam setup failed.");
            }
        });
    </script>
</body>

</html>
