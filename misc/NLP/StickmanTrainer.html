<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Stickman Trainer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-gray-100 font-['Rubik']">
    <div class="p-4 bg-cyan-800 text-white text-center">
        <h1 class="text-3xl text-blue-200 font-bold tracking-wide" style="font-family: 'Playfair Display', serif;">
            Stickman Trainer
        </h1>
    </div>

    <div class="flex flex-col items-center justify-center min-h-screen p-4">
        <!-- Stick Figure Canvas -->
        <canvas id="stickFigureCanvas" width="325" height="325" class="border-2 border-black shadow-md"></canvas>
        <button onclick="generateNewStickFigure()"
            class="mt-4 py-2 px-6 bg-blue-600 text-white font-semibold rounded hover:bg-blue-700 transition-colors">
            Generate New Stick Figure
        </button>

        <!-- Data Submission Section -->
        <div class="w-full sm:w-3/4 lg:w-1/2 mt-6 bg-white p-6 rounded-lg shadow-lg">
            <h2 class="underline text-xl font-semibold text-gray-800">Submit Data:</h2>
            <small class="block text-gray-600"><i>Describe the stickman's pose, feeling, or idea it conveys.</i></small>
            <input type="text" id="txtInput"
                class="w-full mt-2 py-2 px-4 bg-gray-200 text-gray-800 border rounded focus:border-blue-500" />
            <button id="submitButton" onclick="submitText()"
                class="mt-2 px-4 py-2 bg-blue-600 text-white font-semibold rounded hover:bg-blue-800 transition-colors"
                disabled>
                Loading Model...
            </button>
        </div>

        <!-- Angle Display Section -->
        <h2 class="underline text-lg font-bold text-gray-800">Current Angles:</h2>
        <p id="angleDisplay" class="bg-blue-200 border p-1 shadow-inner text-sm font-mono text-gray-700"></p>

        <!-- Semantic Embedding Plot -->
        <canvas id="embeddingPlot" width="400" height="75"
            class="border-2 border-black my-4 shadow-md bg-opacity-40 bg-blue-800"></canvas>

        <!-- Note -->
        <div class="w-full flex justify-end">
            <small class="text-sm italic text-gray-500">
                If you want to play with semantic embedding plots, try <a class="text-blue-700 underline"
                    href="https://cheeseonamonkey.github.io/misc/NLP/USEDemo.html">here</a>.
            </small>
        </div>
    </div>

    <script>
        let model = null;

        async function loadModel() {
            model = await use.load();
            document.getElementById("submitButton").innerText = "Submit";
            document.getElementById("submitButton").disabled = false;
        }

        function generateRandomColor() {
            return `#${Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0')}`;
        }

        async function submitText() {
            const text = document.getElementById("txtInput").value.trim();
            if (!text || !model) return;

            const embedding = await model.embed([text]);
            const embeddingArray = embedding.arraySync()[0];
            const reducedEmbedding = tsneSimple(embeddingArray, 50);
            plotEmbedding(reducedEmbedding, text);
        }

        function plotEmbedding(embedding, label) {
            const canvas = document.getElementById("embeddingPlot");
            const ctx = canvas.getContext("2d");

            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear previous plots

            const step = canvas.width / embedding.length;
            const color = generateRandomColor();

            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            embedding.forEach((val, index) => {
                const x = step * (index + 1);
                const y = canvas.height - (val * canvas.height);
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.stroke();

            // Label the plot
            ctx.fillStyle = color;
            ctx.font = 'bold 12px monospace';
            ctx.fillText(label, Math.random() * canvas.width, 15 + Math.random() * (canvas.height - 30));
        }

        function tsneSimple(arr, reducedSize) {
            const step = Math.ceil(arr.length / reducedSize);
            return Array.from({ length: reducedSize }, (_, i) => {
                const start = i * step;
                const end = Math.min(start + step, arr.length);
                const slice = arr.slice(start, end);
                return slice.reduce((sum, val) => sum + val, 0) / slice.length;
            });
        }

        class StickFigure {
            constructor(angles) {
                this.angles = angles;
                this.draw();
                this.displayAngles();
            }

            static randomAngle() {
                return Math.floor(Math.random() * 121) - 60; // Random angle between -60 and 60
            }

            static createRandom() {
                return new StickFigure(Array(8).fill(0).map(StickFigure.randomAngle));
            }

            draw() {
                const canvas = document.getElementById("stickFigureCanvas");
                const ctx = canvas.getContext("2d");

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.lineWidth = 8;
                ctx.strokeStyle = "#333";

                ctx.beginPath();
                ctx.arc(175, 80, 30, 0, Math.PI * 2); // Head
                ctx.moveTo(175, 112); // Neck
                ctx.lineTo(175, 190); // Body
                ctx.stroke();

                this.drawSegment(ctx, [175, 140], [[-40, 0], [-40, 0]], this.angles[0], this.angles[2]); // Left arm
                this.drawSegment(ctx, [175, 140], [[40, 0], [40, 0]], this.angles[1], this.angles[3]); // Right arm
                this.drawSegment(ctx, [175, 190], [[-40, 50], [-50, 0]], this.angles[4], this.angles[6]); // Left leg
                this.drawSegment(ctx, [175, 190], [[40, 50], [50, 0]], this.angles[5], this.angles[7]); // Right leg
            }

            drawSegment(ctx, start, lengths, angle1, angle2) {
                ctx.save();
                ctx.translate(...start);
                ctx.rotate(angle1 * Math.PI / 180);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(...lengths[0]);
                ctx.translate(...lengths[0]);
                ctx.rotate(angle2 * Math.PI / 180);
                ctx.lineTo(...lengths[1]);
                ctx.stroke();
                ctx.restore();
            }

            displayAngles() {
                const angleText = `
                    Left Arm: ${this.angles[0]}°, \tRight Arm: ${this.angles[1]}° 
                    Left Forearm: ${this.angles[2]}°, \tRight Forearm: ${this.angles[3]}° 
                    Left Leg: ${this.angles[4]}°, \tRight Leg: ${this.angles[5]}° 
                    Left Knee: ${this.angles[6]}°, \tRight Knee: ${this.angles[7]}°
                `.replace(/\t/g, '\t\t');
                document.getElementById("angleDisplay").innerText = angleText.trim();
            }
        }

        function generateNewStickFigure() {
            StickFigure.createRandom();
        }

        window.addEventListener('DOMContentLoaded', async () => {
            await loadModel();
            generateNewStickFigure();
        });
    </script>
</body>

</html>
